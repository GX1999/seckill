# 项目简介
参考视频：https://www.bilibili.com/video/BV1sf4y1L7KE/?p=1&vd_source=3f02a65309de4b7b18d2bb0199f1cf4d
## 1. 登录模块
（1）手机号码参数校验：使用JSR303参数校验对参数LoginVo加注解@valid，例如使用@NotNull定义非空，同时使用ConstraintValidator接口自定义注解验证手机号码格式

（2）密码两次MD5加密+加salt：第一次加密防止在网络传输过程中被截取，第二次加密防止数据库信息泄露被碰撞解码

（3）分布式session问题：登录成功后通过UUID生成token（令牌）标记该用户，并向cookie中写入，客户端在随后的访问中都在cookie加上该token。redis中存储该token和用户信息。

## 2. 商品列表和商品详情页
（1）初始：判断库存以及用户是否重复抢购，若符合条件则减库存，并生成订单和秒杀订单。会出现超买超卖问题。

（2）页面缓存和页面静态化：详见项目优化1

## 3. 秒杀接口
（1）超买、超卖问题优化：详见项目优化2

（2）秒杀接口性能优化：详见项目优化3：

（3）秒杀接口安全优化：详见项目优化4

## 4. Jmeter压测
秒杀接口QPS
（1）windows优化前：1537
（2）windows优化后：

# 项目优化
## 1. 页面缓存、页面静态化
（1）初始：服务器动态生成html文件（将数据库的数据查询后放入到页面中，然后返回客户端）

（2）页面缓存（商品列表）：将整个html的内容放入redis中（数据已经写死在html），若不存在则手动渲染并存入redis

（3）页面静态化（商品详情、秒杀、订单详情）：使用纯html页面+Ajax请求数据后再填充页面，直接把页面缓存到浏览器上，当用户访问页面时，不需要和服务端进行交互，极大地节省了网络流量。具体的数据使用ajax请求来获取，只更新极少量的数据就可。

## 2. 超买、超卖问题
（1）超买（单用户多次秒杀）：原始的方案是先查询数据库秒杀订单中是否存在该userId和seckillGoodsId的记录，后执行是否购买操作。会存在并发问题。通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。在秒杀商品订单表中添加唯一性索引，在秒杀商品订单表中以用户id列和商品id列组合建立一个唯一性索引就可以解决超买问题。
		 
（2）超卖：原始的方案是先查询数据库中库存数量是否大于0，大于零的话再执行减库存的操作，在高并发情况会出现超卖问题的。直接使用update更新数据库，将对应商品的库存减一，如果更新成功的话说明还没有超卖（sql语句判断条件有stock>0）。使用update在mysql中默认加排他锁。
## 3. 秒杀接口性能优化
使用唯一性索引可以解决超买问题，但是过多用户请求直接访问数据库，仍会产生服务器压力过大问题。
（1）秒杀商品信息存入redis中系统初始化完成后，将所有的秒杀的商品的库存信息放入redis中。让SeckillController实现InitializingBean接口，重写里面的afterPropertiesSet方法

（2）使用redis预减库存

使用redis+lua脚本实现原子操作。使用redis预减库存，如果库存不足，直接返回错误。

（3）进一步减少对redis 的访问：内存标记

定义一个HashMap存放秒杀商品是否stock<0 的布尔值。

（4）使用rabbitMQ（Topic模式）处理请求

如果用户符合当前秒杀条件，则将秒杀请求发送到队列，然后接收端会从消息队列中取出消息进行异步下单操作。最后前端轮询查询秒杀结果。
## 4. 秒杀接口安全优化

（1）接口隐藏且唯一：

未到秒杀开始时间时，隐藏秒杀接口地址，避免脚本直接确定地址。页面中秒杀按钮是请求获取秒杀地址，因此黄牛大量请求时也只是获取地址，并不能完成秒杀。
在秒杀之前要随机生成一个path，然后和用户ID一起存入Redis，在执行秒杀的时候再从Redis中取Path进行验证，这样每个用户的秒杀地址都不同且唯一。

（2）接口限流

配合redis消亡时间设置每个用户在一定时间内可请求次数

（3）使用验证码分流

使用开源的验证码项目进行分流（不同用户完成验证时间不相同），将验证码结果存入redis中后续进行验证。
